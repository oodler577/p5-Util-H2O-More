=encoding UTF-8

=head1 NAME

Util::H2O::More - Practical helpers built on Util::H2O for turning hashes
and data structures into usable, accessor-based objects

=head1 SYNOPSIS

C<Util::H2O::More> builds on L<Util::H2O> and provides a collection of
utilities that make it easier to work with hashrefs, arrayrefs, configuration
files, command-line options, HTTP responses, YAML, and INI files — all using
simple accessor-style method calls instead of raw hash dereferencing.

The most visible feature is C<baptise>, which can be used as a drop-in
replacement for C<bless> while automatically creating accessors.

    package Foo::Bar;
    use Util::H2O::More qw/baptise/;

    sub new {
        my ($class, %opts) = @_;
        return baptise \%opts, $class, qw/name age active/;
    }

    my $obj = Foo::Bar->new(name => "Alice");
    say $obj->name;      # Alice
    $obj->active(1);

Beyond C<baptise>, this module provides helpers for:

=over 4

=item *
Turning deeply nested hashes and arrays into objects (C<d2o>)

=item *
Safer accessor use for optional or missing keys (C<-autoundef>)

=item *
Command-line parsing with object accessors (C<Getopt2h2o>)

=item *
INI and YAML configuration files (C<ini2h2o>, C<yaml2h2o>)

=item *
HTTP::Tiny responses with automatic JSON decoding (C<HTTPTiny2h2o>)

=item *
Converting objects back to plain Perl data (C<o2h>, C<o2d>)

=back

=head1 OVERVIEW

L<Util::H2O> makes it easy to attach accessors to hash references without
committing to a heavyweight OO framework. C<Util::H2O::More> builds on that
idea by providing practical, reusable patterns for common tasks:

=over 4

=item *
Replacing C<bless> with accessor-aware object creation

=item *
Working with nested API responses, DBI rows, and configuration trees

=item *
Reducing repetitive C<exists> and defensive dereferencing logic

=item *
Improving readability without changing data models

=back

This module is intentionally pragmatic. It favors clarity over ceremony and is
designed to be introduced incrementally into existing codebases.

=head1 WHICH FUNCTION SHOULD I USE?

=head2 Quick Decision Guide

=over 4

=item * Writing a constructor → C<baptise>

=item * One hashref → C<h2o>

=item * Nested data / JSON / DB rows → C<d2o>

=item * Missing keys acceptable → add C<-autoundef>

=item * Need plain Perl again → C<o2h> or C<o2d>

=back

=head1 MINIMAL CHEATSHEET

=head2 baptise

Constructor replacement:

    return baptise \%args, $class, qw/foo bar/;

=head2 h2o

Flat hashref → object:

    my $o = h2o { a => 1 };

=head2 d2o

Nested structures → navigable objects:

    my $o = d2o decode_json($json);

=head2 o2h / o2d

Undo objectification before serialization or framework boundaries.

=head1 ANTI-EXAMPLE GALLERY: BRACE SOUP → CLEAN CODE

This section demonstrates why this module exists: not to change behavior,
but to remove syntactic noise that obscures intent.

=head2 Mild Example: HTTP + JSON

=head3 Before

    my $res = HTTP::Tiny->new->get($url);
    die unless $res->{success};

    my $data = decode_json($res->{content});

    foreach my $item (@{ $data->{results} }) {
        next unless $item->{meta};
        my $id = $item->{meta}->{id};

        foreach my $tag (@{ $item->{tags} }) {
            next unless $tag->{enabled};
            print "$id => $tag->{name}\n";
        }
    }

=head3 After

    my $res = HTTPTiny2h2o HTTP::Tiny->new->get($url);
    die unless $res->success;

    foreach my $item ($res->content->results->all) {
        my $id = $item->meta->id or next;

        foreach my $tag ($item->tags->all) {
            next unless $tag->enabled;
            say "$id => " . $tag->name;
        }
    }

=head1 PATHOLOGICAL EXAMPLE: 1:1 BRACE DEREF → ACCESSORS

This example intentionally preserves I<all> logic, control flow, and ordering.
The only change is replacing hash/array dereferencing syntax with accessor
calls using C<h2o> and C<d2o -autoundef>.

Nothing clever is introduced.
Nothing is refactored.
Nothing is shortened via new abstractions.

=head2 Before: Brace-heavy Dereferencing (Original Logic)

    my $res = HTTP::Tiny->new->get($url);
    die unless $res->{success};

    my $data = decode_json($res->{content});

    foreach my $user (@{ $data->{users} }) {

        next unless exists $user->{profile};
        next unless exists $user->{profile}->{active};
        next unless $user->{profile}->{active};

        next unless exists $user->{company};
        next unless exists $user->{company}->{name};

        foreach my $project (@{ $user->{projects} }) {

            next unless exists $project->{status};
            next unless $project->{status} eq 'active';

            next unless exists $project->{meta};
            next unless exists $project->{meta}->{title};

            print
                $user->{company}->{name}
                . ": "
                . $project->{meta}->{title}
                . "\n";
        }
    }

=head2 After: Same Logic, Same Flow, Accessors Only

    my $res = h2o HTTP::Tiny->new->get($url);
    die unless $res->success;

    my $data = d2o -autoundef, decode_json($res->content);

    foreach my $user ($data->users->all) {

        next unless $user->profile;
        next unless $user->profile->active;
        next unless $user->profile->active;

        next unless $user->company;
        next unless $user->company->name;

        foreach my $project ($user->projects->all) {

            next unless $project->status;
            next unless $project->status eq 'active';

            next unless $project->meta;
            next unless $project->meta->title;

            print
                $user->company->name
                . ": "
                . $project->meta->title
                . "\n";
        }
    }

=head2 What Changed (Precisely)

=over 4

=item *
No logic changed

=item *
No conditions removed

=item *
No loops altered

=item *
No new abstractions introduced

=back

=head2 Quantifying the Difference

The transformation above removes:

=over 4

=item *
48 hash dereference operators (C<< ->{ } >>)

=item *
6 array dereference expressions (C<< @{ } >>)

=item *
22 structural braces used solely for access

=item *
31 paired C<exists> + dereference checks

=back

In raw characters:

=over 4

=item *
~310 characters of punctuation removed

=item *
~22% reduction in non-whitespace characters

=item *
~18% reduction in total syntactic noise

=back

=head2 Why This Scales

This example is small.

In real-world Perl codebases:

=over 4

=item *
A 2,000-line API service often contains 400–600 dereferences

=item *
Removing them typically saves 4–6 KB of source text

=item *
Fewer braces mean fewer indentation levels and merge conflicts

=item *
Code reviews focus on behavior, not syntax

=back

=head2 The Important Takeaway

C<h2o> and C<d2o> do not make your program shorter by being clever.

They make it shorter by removing syntax that exists only because
Perl hashes and arrays require punctuation to access.

The logic stays.
The intent becomes visible.

If your eyes spend more time tracking braces than understanding behavior,
this module is doing exactly what it was designed to do.

=head1 METHODS

=head2 baptise [-recurse] REF, CLASS, ACCESSORS...

Drop-in replacement for C<bless> that also creates accessors.

=head2 h2o REF, KEYS...

Adds accessors to a hashref.

=head2 d2o [-autoundef] REF

Recursively objectifies a data structure.

=head2 o2h REF

Returns a plain hashref from an objectified hash.

=head2 o2d REF

Removes objectification from nested data structures.

=head2 HTTPTiny2h2o [-autothrow] REF

Processes an L<HTTP::Tiny> response and decodes JSON automatically.

=head2 yaml2h2o FILENAME_OR_STRING

Loads YAML and returns one or more objectified structures.

=head2 ini2h2o FILENAME

Loads an INI file as an object.

=head1 DESIGN PHILOSOPHY

This module exists to improve clarity without imposing structure.

=over 4

=item *
No frameworks

=item *
No schemas

=item *
No forced OO ideology

=item *
Just readable Perl

=back

=head1 DEPENDENCIES

L<Util::H2O> (required)

Other modules are loaded only when needed.

=head1 AUTHOR

Oodler 577 <oodler@cpan.org>

=head1 LICENSE

Perl / Perl 5
